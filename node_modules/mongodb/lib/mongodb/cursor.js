var QueryCommand = require('./commands/query_command').QueryCommand,
  GetMoreCommand = require('./commands/get_more_command').GetMoreCommand,
  KillCursorCommand = require('./commands/kill_cursor_command').KillCursorCommand,
  Long = require('bson').Long,
  ReadPreference = require('./connection/read_preference').ReadPreference,
  CursorStream = require('./cursorstream'),
  timers = require('timers'),
  utils = require('./utils');

// Set processor, setImmediate if 0.10 otherwise nextTick
var processor = require('./utils').processor();

/**
 * Constructor for a cursor object that handles all the operations on query result
 * using find. This cursor object is unidirectional and cannot traverse backwards. Clients should not be creating a cursor directly,
 * but use find to acquire a cursor. (INTERNAL TYPE)
 *
 * Options
 *  - **skip** {Number} skip number of documents to skip.
 *  - **limit** {Number}, limit the number of results to return. -1 has a special meaning and is used by Db.eval. A value of 1 will also be treated as if it were -1.
 *  - **sort** {Array | Object}, set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.
 *  - **hint**  {Object}, hint force the query to use a specific index.
 *  - **explain** {Boolean}, explain return the explaination of the query.
 *  - **snapshot** {Boolean}, snapshot Snapshot mode assures no duplicates are returned.
 *  - **timeout** {Boolean}, timeout allow the query to timeout.
 *  - **tailable** {Boolean}, tailable allow the cursor to be tailable.
 *  - **awaitdata** {Boolean}, awaitdata allow the cursor to wait for data, only applicable for tailable cursor.
 *  - **oplogReplay** {Boolean}, sets an internal flag, only applicable for tailable cursor.
 *  - **batchSize** {Number}, batchSize the number of the subset of results to request the database to return for every request. This should initially be greater than 1 otherwise the database will automatically close the cursor. The batch size can be set to 1 with cursorInstance.batchSize after performing the initial query to the database.
 *  - **raw** {Boolean}, raw return all query documents as raw buffers (default false).
 *  - **read** {Boolean}, read specify override of read from source (primary/secondary).
 *  - **returnKey** {Boolean}, returnKey only return the index key.
 *  - **maxScan** {Number}, maxScan limit the number of items to scan.
 *  - **min** {Number}, min set index bounds.
 *  - **max** {Number}, max set index bounds.
 *  - **maxTimeMS** {Number}, number of miliseconds to wait before aborting the query.
 *  - **showDiskLoc** {Boolean}, showDiskLoc show disk location of results.
 *  - **comment** {String}, comment you can put a $comment field on a query to make looking in the profiler logs simpler.
 *  - **numberOfRetries** {Number}, numberOfRetries if using awaidata specifies the number of times to retry on timeout.
 *  - **dbName** {String}, dbName override the default dbName.
 *  - **tailableRetryInterval** {Number}, tailableRetryInterval specify the miliseconds between getMores on tailable cursor.
 *  - **exhaust** {Boolean}, exhaust have the server send all the documents at once as getMore packets.
 *  - **partial** {Boolean}, partial have the sharded system return a partial result from mongos.
 *
 * @class Represents a Cursor.
 * @param {Db} db the database object to work with.
 * @param {Collection} collection the collection to query.
 * @param {Object} selector the query selector.
 * @param {Object} fields an object containing what fields to include or exclude from objects returned.
 * @param {Object} [options] additional options for the collection.
*/
function Cursor(db, collection, selector, fields, options) {
  this.db = db;
  this.collection = collection;
  this.selector = selector;
  this.fields = fields;
  options = !options ? {} : options;

  this.skipValue = options.skip == null ? 0 : options.skip;
  this.limitValue = options.limit == null ? 0 : options.limit;
  this.sortValue = options.sort;
  this.hint = options.hint;
  this.explainValue = options.explain;
  this.snapshot = options.snapshot;
  this.timeout = options.timeout == null ? true : options.timeout;
  this.tailable = options.tailable;
  this.awaitdata = options.awaitdata;
  this.oplogReplay = options.oplogReplay;
  this.numberOfRetries = options.numberOfRetries == null ? 5 : options.numberOfRetries;
  this.currentNumberOfRetries = this.numberOfRetries;
  this.batchSizeValue = options.batchSize == null ? 0 : options.batchSize;
  this.raw = options.raw == null ? false : options.raw;
  this.readPreference = options.readPreference == null ? ReadPreference.PRIMARY : options.readPreference;
  this.returnKey = options.returnKey;
  this.maxScan = options.maxScan;
  this.min = options.min;
  this.max = options.max;
  this.showDiskLoc = options.showDiskLoc;
  this.comment = options.comment;
  this.tailableRetryInterval = options.tailableRetryInterval || 100;
  this.exhaust = options.exhaust || false;
  this.partial = options.partial || false;
  this.slaveOk = options.slaveOk || false;
  this.maxTimeMSValue = options.maxTimeMS;
  this.connection = options.connection;
  this.transforms = options.transforms;

  this.totalNumberOfRecords = 0;
  this.items = [];
  this.cursorId = Long.fromInt(0);

  // This name
  this.dbName = options.dbName;

  // State variables for the cursor
  this.state = Cursor.INIT;
  // Keep track of the current query run
  this.queryRun = false;
  this.getMoreTimer = false;

  // If we are using a specific db execute against it
  if(this.dbName != null) {
    this.collectionName = this.dbName + "." + this.collection.collectionName;
  } else {
    this.collectionName = (this.db.databaseName ? this.db.databaseName + "." : '') + this.collection.collectionName;
  }
}

/**
 * Clones a given cursor but uses new options
 * @param  {Cursor} cursor the cursor to clone.
 * @return {Object} [options] additional options for the collection when cloning.
 */
Cursor.cloneWithOptions = function(cursor, options) {
  return new Cursor(cursor.db, cursor.collection, cursor.selector, cursor.fields, options);
}

/**
 * Resets this cursor to its initial state. All settings like the query string,
 * tailable, batchSizeValue, skipValue and limits are preserved.
 *
 * @return {Cursor} returns itself with rewind applied.
 * @api public
 */
Cursor.prototype.rewind = function() {
  var self = this;

  if (self.state != Cursor.INIT) {
    if (self.state != Cursor.CLOSED) {
      self.close(function() {});
    }

    self.numberOfReturned = 0;
    self.totalNumberOfRecords = 0;
    self.items = [];
    self.cursorId = Long.fromInt(0);
    self.state = Cursor.INIT;
    self.queryRun = false;
  }

  return self;
}


/**
 * Returns an array of documents. The caller is responsible for making sure that there
 * is enough memory to store the results. Note that the array only contain partial
 * results when this cursor had been previouly accessed. In that case,
 * cursor.rewind() can be used to reset the cursor.
 *
 * @param {Function} callback This will be called after executing this method successfully. The first parameter will contain the Error object if an error occured, or null otherwise. The second parameter will contain an array of BSON deserialized objects as a result of the query.
 * @return {null}
 * @api public
 */
Cursor.prototype.toArray = function(callback) {
  var self = this;

  if(!callback) {
    throw new Error('callback is mandatory');
  }

  if(this.tailable) {
    callback(new Error("Tailable cursor cannot be converted to array"), null);
  } else if(this.state != Cursor.CLOSED) {
    // return toArrayExhaust(self, callback);
    // If we are using exhaust we can't use the quick fire method
    if(self.exhaust) return toArrayExhaust(self, callback);
    // Quick fire using trampoline to avoid nextTick
    self.nextObject({noReturn: true}, function(err, result) {
      if(err) return callback(utils.toError(err), null);
      if(self.cursorId.toString() == "0") {
        self.state = Cursor.CLOSED;

        // If we have a transform
        if(typeof self.transforms == 'function') {
          self.items = self.transforms(self.